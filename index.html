<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-HwwvtgBNo3bZJJLYd8oVXjrBZt8cqVSpeBNS5n7C8IVInixGAoxmnlMuBnhbgrkm"
        crossorigin="anonymous"></script>
    <link rel="stylesheet" href="CC.css">

    <title>Compiler Construction</title>
</head>
<style>
    * {
  margin: 0;
  padding: 0;
  font-family: Arial, Helvetica, sans-serif;
}

.img {
  width: 1000px;
}

.final {
  border: 10px solid black;
}

body {
  margin: 20px 0px;
}

pre {
  overflow: auto;
  height: fit-content;
  width: fit-content;
  white-space: pre-wrap;
  word-wrap: normal;
}

h6 {
  position: relative;
  left: 200px;
}

.text-center {
  font-size: 24px;
}

.text-start {
  position: relative;
  left: 200px;

  width: 1200px;
  font-size: 20px;
}

.dates {
  color: red;
}

hr {
  border-color: red;
  height: 20px;
}

.diagram {
  width: fit-content;
  border: 2px solid black;
  display: inline;
  margin: 80px;
}

.diagram-container {
  position: relative;
  left: 200px;
}

ul li {
  position: relative;
  left: 200px;
  width: 1200px;
  font-size: 20px;
}

ol li {
  position: relative;
  left: 200px;
  width: 1200px;
  font-size: 20px;
}

p {
  position: relative;
  left: 300px;
  width: 1200px;
  font-size: 20px;
}

</style>
<body>
    <h1 class="text-center">Compiler Construction</h1>
    <h6 class="text-start dates">4th Oct 2023: -</h6>
    <p class="text-center"><u>Basic Introduction of the Course Title</u></p>
    <p class="text-start">CC deals with the behind the scenes of any program, how errors happen and what is displayed at
        that particular time?</p>
    <!-- Diagram -->
    <div class="diagram-container">
        <p class="diagram">Human / User</p>
        <span style='font-size:40px; position: relative; left: 315px;'>&#8594;</span>
        <span style='font-size:40px; position: relative; right: -271px; top: 20px;' class="arrow-left">&#8592;</span>
        <p class="diagram">Compiler / Translator</p>
        <span style='font-size:40px; position: relative; left: 315px;'>&#8594;</span>
        <span style='font-size:40px; position: relative; right: -271px; top: 20px;' class="arrow-left">&#8592;</span>
        <p class="diagram">System / Machine</p>
        <!-- Tables -->
    </div>
    <table class="table table-hover table-bordered table-responsive" style="width: fit-content; text-align: center; position: relative;
left: 250px; margin-top: 50px;">
        <tr>
            <th>
                Formal Language
            </th>
            <th>
                Informal Language
            </th>
        </tr>
        <tr>
            <td>Proper Syntax and has a single meaning.</td>
            <td>May or mayn't have a proper syntax and has an Ambiguous meaning.</td>
        </tr>
    </table>

    <table class="table table-hover table-bordered table-responsive" style="width: fit-content; text-align: center; position: relative;
left: 250px; margin-top: 50px;">
        <tr>
            <th>
                Machine Code
            </th>
            <th>
                Object Code
            </th>
        </tr>
        <tr>
            <td>Executable</td>
            <td>Need to be compiled more before execution.</td>
        </tr>

        <tr>
            <td colspan="2">Both are translated.</td>
        </tr>
    </table>

    <p class="text-center"><u>APPLICATIONS</u></p>
    <h6 class="text-start">Theory of Automata : -</h6>
    <p class="text-start">Helps create a syntax of new language.</p>

    <h6 class="text-start">Compiler Construction: -</h6>
    <p class="text-start">Helps create a new compiler for a particular language.</p>


    <div class="diagram-container">
        <p class="diagram">Machine Code (c70600000002)
        </p>

        <span style='font-size:40px; position: relative;
        left: 277px;'>&#8594;</span>

        <p class="diagram">Assembly / Symbolic language (mov x,2)</p>
        <span style='font-size:40px; position: relative;
        left: 277px;'>&#8594;</span>

        <p class="diagram">High-level / Human Readable language (x =2)</p>
    </div>

    <hr>

    <h6 class="text-start dates">6th Oct 2023: -</h6>
    <p class="text-center"><u>Files in a Compiler</u></p>

    <ul>
        <li>Source Code File</li>
        <li>Intermediate</li>
        <p>Produced by Compiler in Backend.</p>
        <li>Assembly Code File</li>
        <p>Old Compiler used to convert into Assembly.</p>
        <li>Binary Object Code</li>
        <li>Executable</li>
        <p>exe for c++, .jar for java</p>
    </ul>

    <p class="text-center"><u>Ingredients in a Compiler</u></p>
    <table class="table table-hover table-bordered table-responsive" style="width: fit-content; text-align: center; position: relative;
left: 250px; margin-top: 50px;">
        <tr>
            <th>
                Compiler
            </th>
            <th>
                Interpretor
            </th>
        </tr>
        <tr>
            <td>Error Free Program is a must or else the code won't run.</td>
            <td>Displays the result until the error.</td>
        </tr>

        <tr>
            <td>Complete at once</td>
            <td>Line by line Execution</td>
        </tr>

        <tr>
            <td>Very Fast</td>
            <td>Slow</td>
        </tr>

        <tr>
            <td>Example C++</td>
            <td>Python</td>
        </tr>
        <tr>
            <td colspan="2">JavaScript & Java are both</td>
        </tr>
    </table>

    <p class="text-center"><u>Assembler</u></p>
    <ul>
        <li>Architecture Dependent</li>
        <p>something working in one device may not work in another.</p>
        <li>Difficult</li>
        <li>.asn extension</li>
    </ul>

    <p class="text-center"><u>Linkers & Loaders</u></p>
    <p class="text-start">Provides Environment to the code during Execution</p>
    <h6 class="text-start"><big>Linkers: -</big></h6>
    <p class="text-start">Links all translated code together, imports all external libraries to make the object code
        executable.</p>
    <h6 class="text-start"><big>Loaders: -</big></h6>
    <p class="text-start">Loads values of variables, arrays and it is part of Operating System.</p>
    <pre class="text-start">var x;
    here, x is a variable which has some physical memory location and this will be assigned by loaders.
</pre>
    <h6 class="text-start"><big>Preprocessors: -</big></h6>
    <p class="text-start">They prepare code for compilation by removing extra code like comments.</p>
    <p class="text-start"><big>Editors</big></p>
    <p class="text-start">They are used to make the code more visible by displaying various colors. For Example: - IDE
        (Integrated Development Environment)</p>
    <p class="text-start"><big>Debuggers</big></p>
    <p class="text-start">They are to remove the bugs from the code.</p>
    <table class="table table-hover table-bordered table-responsive" style="width: fit-content; text-align: center; position: relative;
left: 250px; margin-top: 50px;">
        <tr>
            <th>Errors / Mistakes</th>
            <th>Bug / Fault / Defect</th>
        </tr>
        <tr>
            <td>Caused by human mistake</td>
            <td>caused when the mistake caused by human becomes a part of a program.</td>
        </tr>
    </table>
    <p class="text-start">Some ways to get rid of errors.</p>
    <ul>
        <li>by putting console.log(""); to check the location of error.</li>
        <li>Adding break points.</li>
    </ul>
    <p class="text-start"><big>Profiles: -</big></p>
    <p class="text-start">Attributes like lines, functions and variables. They are used to improve the program.</p>
    <p class="text-start"><big>Project Manager: -</big>
    </p>
    <p class="text-start">they manage modules & components of code. For Example: - Git (version control / monitoring)
    </p>

    <h6 class="text-center dates">There are 6 core and 3 supportive components of any compiler.</h6>
    <h6 class="text-center"><big><u>Core Components</u></big></h6>
    <h6 class="text-start"><big>Analysis Phase / Frontend of a Compiler: -</big></h6>
    <ol>

        <li>Tokenization</li>
        <p class="text-start">Scanner takes source code as input. All words are separated in Tokenization and are
            performed in scanner. Hence, it's called <b>Scannical Process</b> or <b>Lexical Analyser.</b> Words in a
            program are called tokens. Scanning is done to verify the syntax.</p>
        <li>Parsers: -</li>
        <p class="text-start">Parsers take this as input and is called as <b>Syntax Analyser.</b> It has the largest
            database in all the components of the compiler.</p>
        <ul>
            <li>Rules of words</li>
            <li>Rules of valid words</li>
            <li>Rules of sentences</li>
            <li>Rules of valid sentences</li>
            <p class="text-start dates">This becomes <b>Grammer </b> and is checked by the Scanner. </p>
        </ul>
        <li>Sematics Analyser: -</li>
        <p class="text-start">This, in a form of tree becomes output of parser & input of <b>sematics analyser </b>
            which checks the meanings. It checks the data types like let a (int) = "xyz" (string); is correct because of
            right syntax. </p>
        <p class="text-start dates">Valid Syntax includes "Words", "Order of Words & Sentences" & "Meaning".</p>
        <h6 class="text-start"><big>Synthesis Phase / Backend of Compiler Extraction: -</big></h6>
        <li>Constant Folding: -</li>
        <p class="text-start">let a = 4+3; , the compiler will make it 7 to save + operation and this is called constant
            folding.</p>
        <li>Loop Unfolding: - </li>
        <p class="text-start">That code doesn't have to go back again and again.</p>
        <li>Code Generatior: -</li>
        <p class="text-start">Works further at low level. Target Code Optimization is done by the compiler itself.</p>
    </ol>
    <h6 class="text-center"><big><u>Supportive Components</u></big></h6>
    <ol>
        <li>Literal Table: -</li>
        <p class="text-start">Data instances, every word & number.</p>
        <li>Symbol Table: -</li>
        <p class="text-start">Second largets data-structure after the data-structure of syntax tree.</p>
        <li>Error Handling: -</li>
        <p class="text-start">If program closes abnormally, error handlers works to stop it in a smoother way.</p>
    </ol>
    <hr>
    <div class="text-start dates">11th Oct 2023</div>
    <p class="text-center"><big>CLASS CANCELLED</big></p>
    <hr>
    <div class="text-start dates">
        13th Oct 2023
    </div>
    <h6 class="text-center">
        Scanning Process
    </h6>
    <p class="text-start">Also known as Tokenization< / Lexical Analysis. 1 piece===1 token. It divides the words and
            figure out the invalid syntax.</p>
            <p class="text-start">Program => Scanner => Correct/Error</p>
            <p class="text-start">The output of the scanner is a list of tokens. Order has same output as that of the
                code.</p>
            <p class="text-start">
                Comments are already removed by the preprocessors.
            </p>
            <p class="text-start">Token === Lexeme of a language.</p>
            <p class="text-center">Characteristics of Tokens</p>
            <ol>
                <li>Lexeme</li>
                <p class="text-start">Lexeme is also known as <b>Token String</b> which are words written by the code
                    and surely are visible to everyone.</p>
                <li>Set of Attributes of the Token</li>
                <p class="text-start">Attributes adds meaning, an additional property of a token => creates semantics to
                    a program. It's done by <big>Semantic Analyser</big>.</p>
                <p class="text-start">Otherwise, everything is a lexeme / token for scanner.</p>
                <p class="text-center">Attribute => Datatype / Scope / Value / Memory Location</p>
                <p class="text-center">let x = 3232; where value is the Attribute.</p>
            </ol>

            <p class="text-center"><big>Categories of a Token / Lexeme</big></p>
            <ol>
                <li>Reserved Words</li>
                <p class="text-start">They are reserved for a specific purpose and can't be used in any other thing.</p>
                <p class="text-start">For Example: - </p>
                <ul>
                    <li>let</li>
                    <li>const</li>
                    <li>var</li>
                    <li>console</li>
                    <li>for</li>
                    <li>while</li>
                </ul>
                <li>Special Symbols which can have only one possible lexeme. For Example: -</li>
                <p class="text-start">They include the operations.</p>
                <p class="text-start">For Example: -</p>
                <ul>
                    <li>Relational Operations which are used for comparisons.</li>
                    <ul>
                        <li>== or ===</li>
                        <li>>= or != </li>
                    </ul>
                    <li>Assignment Operations which are used to assign the values.</li>
                    <ul>
                        <li>=</li>
                        <li>+=</li>
                    </ul>
                    <li>Arithmetic Operations which can have only one possible lexeme. For Example: -</li>
                    <ul>
                        <li>+</li>
                        <li>/</li>
                        <li>*</li>
                    </ul>
                    <li>Colons & apostrophes like ; " ' ` </li>
                    <li>Brackets like () {} []</li>
                </ul>
                <li>Other Tokens</li>
                <p class="text-start">They include identifiers & all literals and they can have infinitely many lexemes.
                </p>
                <ul>
                    <li>identifiers</li>
                    <p class="text-start">Identifiers are the names of anything like class, function, array, object or
                        variable. Even numbers are also a part of other tokens category. Any name or number can be
                        replaced by infinite possibilites. </p>
                    <p class="text-center"><big>Lexemes => Tokens => Numbers / Words => Replacements</big></p>
                    <li>Literals</li>
                    <p class="text-start">Literal means Meaning.</p>
                    <ul>
                        <li>Integers</li>
                        <li>Real Numbers (decimal / fractional numbers)</li>
                        <li>Characters</li>
                        <li>Strings</li>
                    </ul>
                </ul>
            </ol>
            <p class="text-center"><big><b><u>Example of Tokens</u></b></big></p>
            <table class="table table-hover table-bordered table-responsive" style="width: fit-content; text-align: center; position: relative;
            left: 250px; margin-top: 50px;">
                <tr>
                    <th>Lexeme</th>
                    <th>Token</th>
                    <th>Category</th>
                </tr>
                <tr>
                    <td>void</td>
                    <td>VOID</td>
                    <td>Reserved Word</td>
                </tr>
                <tr>
                    <td>main</td>
                    <td>ID</td>
                    <td>other token</td>
                </tr>
                <tr>
                    <td>(</td>
                    <td>left bracket</td>
                    <td>special symbol</td>
                </tr>
                <tr>
                    <td>)</td>
                    <td>right bracket</td>
                    <td>special symbol</td>
                </tr>
                <tr>
                    <td>{</td>
                    <td>left curly</td>
                    <td>special symbol</td>
                </tr>
                <tr>
                    <td>int</td>
                    <td>integer</td>
                    <td>reserved word</td>
                </tr>
                <tr>
                    <td>A</td>
                    <td>ID</td>
                    <td>other token</td>
                </tr>
                <tr>
                    <td>=</td>
                    <td>equal</td>
                    <td>special symbol</td>
                </tr>
            </table>
            <p class="text-start">DFA recognizes the words in a scanner.</p>
            <table class="table table-hover table-bordered table-responsive" style="width: fit-content; text-align: center; position: relative;
            left: 250px; margin-top: 50px;">
                <tr>
                    <th>Lexical Error</th>
                    <th>Syntax Error</th>
                </tr>
                <tr>
                    <td>Lexical Errors are related to some mistake like using reserved word as identifier.</td>
                    <td>Syntax Errors are related to mistakes of grammer like missing semi colon or brackets.</td>
                </tr>
            </table>
            <hr>
            <p class="text-start dates">
                18th Oct 2023
            </p>
            <h6 class="text-center">Regular Expressions</h6>
            <p class="text-start">In order to create a new programming language, we need 3 types of rules.</p>
            <ol>
                <li>Lexical Rules</li>
                <p class="text-start">Lexical Rules are those which provide information about alphabets and set of valid
                    words. They are defined by the techniques like
                <ol>
                    <li>recursive rules</li>
                    <li>regular expressions</li>
                    <li>finite automata</li>
                    <li>transition graphs</li>
                </ol>
    </p>
    <p class="text-start">Alphabets are denoted with "capital sigma" symbol and set of valid words are denoted with
        "capital gamma" symbol.
    <ol>
        <li>Sigma set has to be a finite set (countable).</li>
        <li>set of valid words can either be finite or infinite.</li>
    </ol>
    </p>
    <li>Syntactical Rules</li>
    <p class="text-start">Syntactical Rules define the grammer of a language. The syntax tells how words should be
        arranged (the order) to form a sentence.</p>
    <p class="text-start">Syntactical Rules can be defined by using various techniques like
    <ol>
        <li>Context Free Grammer</li>
        <li>Push Down Automata</li>
        <li>Turing Machines</li>
        <li>Syntax Diagram</li>
    </ol>
    </p>
    <li>Semantic Rules</li>
    <p class="text-start">Semantic Rules explains how the sentence should be interpreted. Check whether the sentencs
        make sense in the context of program. They define the rules for datatypes & type checking and the scope of
        identifiers and declaration rules.</p>
    <p class="text-start">Semantic Rules can be defined by using techniques like
    <ol>
        <li>Attribute Grammer which use attributes of the language entities to define attribute equation.</li>
    </ol>
    </p>
    <p class="text-center">Need of Regular Expression</p>
    <p class="text-start">When we need to know about a finite words, we check dictionary to figure out if its valid or
        invalid. But, what if we have infinite words? In this case, we use some formulas which are called Regular
        Expressions.</p>

    <p class="text-center">Characteristics of Regular Expressions</p>
    <ul>
        <li>Similar to Arithmetic Expression</li>
        <li>They are word generators and can generate both finite and infinite words.</li>
        <li>words made by a regular expression is a part of its language.</li>
    </ul>
    <p class="text-start">All words that can be generated by a Regular Expression are called language of that Regular
        Expression & is denoted with L(r) or language of r.</p>

    <h6 class="text-center">Regular Expression Operations</h6>
    <ol>

        <li>Addition (+)</li>
        <li>Product (Concatenate)</li>
        <li>Closure (0 or Many)</li>
    </ol>

    <p class="text-center">Null String</p>
    <p class="text-start">Visible string of length zero, denoted by Capital Lambda or Absalon</p>

    <div class="text-center">
        <p>All words ending with "ab"</p>
        <p>r = (a+b)*ab</p>
        <br>
        <p>all words starting with "a" & ends with a "b"</p>
        <p>r = a(a+b+c)*b</p>
        <br>
        <p>all words with exactly "a"</p>
        <p>r = (b+c)*a(b+c)*</p>
        <br>
        <p>all "a"s or "b"s</p>
        <p>r == aa* + bb*</p>
        <br>
        <p>atleast one "b"</p>
        <p>r = (a + b + c)* b (a+b+c)*</p>
        <br>
        <p>at most one "b"</p>
        <p>r = (a+c)*b(a+c)*</p>
        <br>
        <p>start and end with different letters</p>
        <p>r = a (a + b + c)* (b + c) + b (a + b + c)* (a + c) + c (a + b + c)* (a + b)</p>
        <br>
        <p>odd numbers of "b" </p>
        <p>?</p>
    </div>
    <hr>
    <p class="text-start dates">20th Oct 2023</p>
    <p class="text-start">Capital Gamma:</p>
    <p class="text-start">Set of all valid words like a dictionary</p>
    <h6 class="text-center">Regular Expression vs Finite Automata</h6>
    <table class="table table-hover table-bordered table-responsive">
        <tr>
            <th>Regular Expression</th>
            <th>Finite Automata</th>
        </tr>
        <tr>
            <td>textual format</td>
            <td>graphical representation</td>
        </tr>
        <tr>
            <td>generate words (Left to Right)</td>
            <td>recognize words (Right to Left)</td>
        </tr>
    </table>
    <p class="text-start">Finite Automata and Regular Expressions are <b>Semantically Equivalent</b> and have the same
        purpose. Being Textual, Regular Expressions are more difficult as compared to the Finite Automata which is a
        graphical representation.</p>
    <h6 class="text-center">Components of Finite Automata</h6>
    <ol>
        <li>Alphabets</li>
        <p class="text-start">They are represented by "Capital Segma" and are never infinite.</p>
        <li>Set of finite states</li>
        <p class="text-start">States are often called Memory Location. Every state must have a unique identifier (name).
            It has 3 parts:-
        <ol>
            <li>Initial State</li>
            <p class="text-start">They are always 1.</p>
            <li>Intermediate State</li>
            <p class="text-start">Can be 0 or many.</p>
            <li>Final State</li>
            <p class="text-start">Can be 0 or many. Automata is Self Automated Machine. If a Finite Automata doesn't
                have a final state, it recognizes an empty language.</p>
        </ol>
        </p>
        <li>set of transitions</li>
        <p class="text-start">Transition is a directed edge that allows Finite Automata to move from one state to
            another. In Finite Automata, transitions are labeled with symbols from sigma set. This process is called
            <b>Labelling</b>.
        </p>
        <p class="text-center">-1 => +2 , the value of transition the arrow will have would be in E = {?}, E means
            Capital Sigma.</p>
    </ol>
    <p class="text-center">Ways to display the Graphs of Finite Automata</p>
    <ul>
        <li>=> q<sub>0</sub> => q<sub>1</sub> => q<sub>2</sub> where final form will be enclosed by two circles.</li>
        <li>-1 => 2 => +3</li>
    </ul>
    <h6 class="text-center">Types of Finite Automata</h6>
    <ol>
        <li>Deterministic Finite Automata (DFA)</li>
        <p class="text-start">determines all transitions. formula: <b>#Q X #E</b>, where Q is set of finite states and E
            is the
            sigma set. <b>States X Sigma Members = Transistors</b>
        <ol>
            <li>Transitions should be Complete.</li>
            <li>Every state must have a unique transitions for every symbol for the sigma set.</li>
        </ol>
        </p>
        <li>Non-Deterministic Finite Automata (NFA)</li>
        <p class="text-start">FA becomes NFA, if one or more conditions are full filled.
        </p>
        <h6 class="text-center">Characteristics of NFA</h6>
        <ol>
            <li>missing transitions</li>
            <li>absolone transitions</li>
            <li>duplicate transitions</li>
        </ol>
    </ol>
    <p class="text-start">Hault isn't a state, when finite automata do not find a single option to move on, it haults.
    </p>
    <p class="text-start">Language of all words that ends at "ab"</p>
    <p class="text-start">FA = -1 -- (a,b) => 2 -- (b) => +3 where final state (+3) moves back to 2 at "a" and loops at
        "b"</p>
    <h6 class="text-center">Representation of NFA</h6>
    <ol>
        <li>Graphical Representation</li>
        <li>Mathematical Representation</li>
        <ol>
            <li>Q = {1,2}</li>
            <li>E = {a,b}</li>
            <li>q<sub>0</sub> = 1</li>
            <p class="text-start">here, 1 isn't in a set because its a single entity.</p>
            <li>F = {2}</li>
            <p class="text-start">it's a set because it can have more than one value.</p>
            <li>Small Delta</li>
            <p class="text-start">delta (state, input) = reaches</p>
            <p class="text-start">delta (-1, a) = 1</p>
            <p class="text-start">delta (-1, b) = 2</p>
            <p class="text-start">delta (2, a) = 1</p>
            <p class="text-start">delta (2, b) = 2</p>

            <table class="table table-responsive table-hover table-bordered">
                <tr>
                    <th>delta</th>
                    <th>sigma</th>
                    <th>gamma</th>
                </tr>
                <tr>
                    <td><img src="/Pictures/sigma.jpg" alt="check picture folder"></td>
                    <td><img src="/Pictures/delta.jpg" alt="check picture folder">
                    </td>
                    <td><img src="/Pictures/gamma.jpg" alt="check picture folder">
                    </td>
                </tr>

            </table>
        </ol>
        <li>Table</li>
        <p class="text-start">This is the most useful and easy to automate way where rows==states, columns==symbols of
            alphabets</p>
        <table class="table table-responsive table-hover table-bordered">
            <tr>
                <th></th>
                <th>a</th>
                <th>b</th>
            </tr>
            <tr>
                <th>-1</th>
                <td>1</td>
                <td>2</td>
            </tr>
            <tr>
                <th>+2</th>
                <td>1</td>
                <td>2</td>
            </tr>
        </table>
    </ol>
    <hr>
    <p class="text-start dates">25th Oct 2023</p>
    <p class="text-center">CONTEXT FREE GRAMMER (CFGs)</p>
    <p class="text-start">CFGs are used to define the syntax of programming language. CFGs are based on 3 components:-
    </p>
    <ol>
        <li>Terminals</li>
        <p class="text-start">Sigma set contains Terminal.</p>
        <li>Non Terminal</li>
        <li>Set of Productions</li>
    </ol>
    <p class="text-start">CFGs are similar to Regular Expressions except CFGs has recursion. Both are text based. CFGs
        are closure for repetitions. The recursion makes CFGs a stronger technique than REs (Regular Expressions).</p>
    <table class="table table-bordered table-hover table-responsive">
        <tr>
            <th>Context Free Grammer</th>
            <th>Regular Expression</th>
        </tr>
        <tr>
            <td>textual</td>
            <td>textual</td>
        </tr>
        <tr>
            <td>recursion</td>
            <td>no recursion</td>
        </tr>
        <tr>
            <td>has a lot of words as compared to regular expressions</td>
            <td>has a very less words as compared to context free grammer</td>
        </tr>
        <tr>
            <td>CFGs are used for generating sentences</td>
            <td>REs are used for generating words</td>
        </tr>
        <tr>
            <td>has words in sigma set</td>
            <td>has alphabets in sigma set</td>
        </tr>
    </table>
    <p class="text-start">what a regular expression can do, context free grammer can also do, but what a context free
        grammer can do, regular expression may or may not be able to do.</p>
    <p class="text-center">Subsumtion Property</p>
    <p class="text-start">CFGs subsumes REs. A language that can be defined by a regular expression can be defined using
        a context free grammer. But, the language that can be defined by a context free grammer may or may not be able
        to be defined by a regular expression.</p>
    <p class="text-start">In general, regular expressions are used to define <b> lexical</b> specification of a
        language. Whereas, CFGs are uesd to define the <b>syntactic</b> specification of a language.</p>
    <p class="text-center">Meta Symbols in CFGs</p>
    <p class="text-start">meta means those with one specific use or function.</p>
    <pre class="text-start">
        N => ND | D
        D => 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
        
        left side represents <b>non terminal</b> which do not terminate. Whereas, right side represents <b>terminals</b> because they terminates the process. The symbol "=>" in between are called <b>productions symbol</b> and the bars "|" represent selection or choice operator. Abselon E represents null.
    </pre>
    <p class="text-start">non terminating can either be on left or on the production in terms of recursion (recalling
        again).</p>
    <p class="text-start">terminating belong to the sigma set as all the values in terminating must be available in the
        capital sigma. they can never be at the right side.</p>
    <p class="text-center">Recursion</p>
    <p class="text-start">When an entity refers to itself within its body is called Recursion. Like some Functions call
        themselves again are known as recursive functions. Recursion is an optional feature in the context free grammer
        but it is the strengh when used.</p>
    <pre class="text-start">
            N => ND | D, here N is being recalled again so is the recursion.
        </pre>
    <p class="text-center">Types of Recursions</p>
    <ol>
        <li>Simple</li>
        <p class="text-start">when the recursion happens at the center of two values. A => AaA </p>
        <li>Left</li>
        <p class="text-start">when the recursion happens at the left. A => Aa</p>
        <li>Right</li>
        <p class="text-start">when the recursion happens at the right. A => aA</p>
        <li>Circular</li>
    </ol>
    <pre class="text-start">A => Aa | AaA | aA | B, here we have total 3 recursions. A is the starting symbol at left (non terminating), followed by left, left, right and right recursions.
        B => bBb | E, here we have one recursion that is simple recursion.
    </pre>
    <p class="text-start">BNS : - Backus-Naur Form</p>
    <p class="text-start">How CFGs produce words?</p>
    <pre class="text-start">E => (E) | n
        here, we have 1 non terminal and 3 terminals i.e. E, (), n values. 
        1 recursion is happening i.e. simple recursion (at the center of parenthesis).
        E => n (smallest possible)
        E => (E) => n 
        E => (E) = ((E))
        E is non terminating so can create words again and again.

        Thus, the result... 
        Capital Gamma = {n, (n), ((n))...}
    </pre>
    <pre class="text-start">
    E => (E)

    Capital Gamma = {}
    null value because, recursive E is non terminating and will produce infinite values. Result can't be displayed until the process is finished which isn't going to happen here.
</pre>
    <pre class="text-start">
    A => Aa | a 

    A => a 
    A => Aa => aa
    A => Aa => Aaa => aaa 

    Thus, Capital Gamma = {a, aa, aaa...} or aa*
</pre>

    <hr>
    <p class="text-start dates">27th Oct 2023</p>
    <h6 class="text-center">CFGs Applications</h6>
    <p class="text-start">The applications of Context Free Grammer are:-</p>
    <ul>
        <li>EBNF</li>
        <li>derivations</li>
        <li>Parse Tree</li>
        <li>Syntax Tree</li>
        <li>Ambigous Grammer</li>
        <li>Syntax Diagram</li>
        <li>Parsing Algorithms</li>
    </ul>
    <p class="text-center">start and end with different alphabet</p>
    <pre class="text-start">
        Σ = {a,b} 

RE = {a(a+b)*b + b(a+b)*a} 
CFG = S => a X b | b X a 
X => aX | bX | Ɛ
    </pre>

    <p class="text-center">b at second position</p>
    <pre class="text-start">
        Σ = {a,b} 

        RE = {(a+b)b(a+b)*} 
        CFG = S => abX | bbX
        X => aX | bX | Ɛ

        or 

        CFG = S => AbX 
        A => a | b 
        X => aX | bX | Ɛ
    </pre>

    <p class="text-center">c at second last</p>
    <pre class="text-start">
        Σ = {a,b,c} 
        
        RE = {(a+b+c)*c(a+b+c)}
        CFG = S => AcX
        A => a | b | c 
        X => a | b | c | Ɛ
        ?  
    </pre>

    <p class="text-center">regular expression for a<sup>n</sup>b<sup>n</sup> , n>=1</p>
    <pre class="text-start">
        RE = {a*b*} , since its an irregular language which won't stop the process so regular expression isn't possible.
    </pre>

    <p class="text-center">context free grammer for a<sup>n</sup>b<sup>n</sup> , n>=1</p>
    <pre class="text-start">
        CFG = S => a S b | ab 
        where, S represents the recursion at center which will be equal for both the surrounding values.
    </pre>

    <p class="text-center">CFG for a<sup>n</sup>b<sup>m</sup>a<sup>n</sup> , n & m >=1</p>
    <pre class="text-start">
        S => a S a | aBa 
        B => bB | b
    </pre>

    <p class="text-center">CFG for a<sup>n</sup>b<sup>m+n</sup></p>
    <pre class="text-start">
        practice question for home
    </pre>

    <p class="text-center">Derivations</p>
    <p class="text-start">It's a process of generating strings which are beginning from start symbol & by applying one
        or more production rules. It can either be left most or right most derivation. In easy wording it is same as
        making strings using CFGs.</p>
    <p class="text-center">Importance of Derivations</p>
    <p class="text-start">When we click compile after writing program, computer has CFG of the program and make it again
        using its own existing CFG. If derivation is correct than ok, else it will display an error. </p>

    <p class="text-center">Assumptions</p>
    <p class="text-start">CFG of language</p>
    <pre class="text-start">
            S => ABC | Ɛ
            A => aA | a 
            B => bB | b 
            C => cC | Ɛ

            the program is <b>"aabbbc"</b>

            Using left most derivation:- 
          1) S => ABC (S => ABC)
          2)  => aABC (A => aA)
          3)  => aaABC (A => aA)
          4)  => aabBC (B => bB)
          5)  => aabbBC (B => bB) 
          6)  => aabbbBC (B => bB)
          7)  => aabbbcC (C => cC)
          8)  => aabbbc (C => Ɛ)

          It can also be done using right most derivation and will have almost similar steps to perform.
        </pre>
    <p class="text-center">derivation for:-</p>
    <pre class="text-start">exp => exp op exp | (exp) | number
            op => + | - | *

            this statement has 2 non terminals <b>exp , op</b>
            6 terminals <b>( , ) , number , + , - , *</b>
            6 productions which are 
            1) exp => exp op exp
            2) exp => (exp)
            3) exp => number
            4) op => +
            5) op => -
            6) op => *


            left most derivation for:
            30*(40-20)+45

            1) number * (40 - 20) + 45 
            2) number op (40 - 20) + 45
            3) number op ... ?
        </pre>

    <hr>
    <p class="text-start dates">1st November 2023</p>
    <h6 class="text-center">Parse Tree</h6>
    <p class="text-start">The parse trees are built from derivations of strings. Frontend => graphical representation &
        Backend => data structures</p>
    <p class="text-start">Parse tree is a pointer based tree that has nodes which represent:-</p>
    <ul>
        <li>root node represents the start symbol</li>
        <li>the leaf node represents the terminals</li>
        <li>the interior nodes represents the node terminals</li>
        <li>the sub tree containing a parents and its children represents one step in derivation or production rule.
        </li>
    </ul>
    <p class="text-start">the interior nodes can be labeled to show the order of the derivation.</p>
    <pre class="text-start">
    exp => exp op exp | (exp) | n
    op => + | - | *

    derive the following equation:-
    30 + 40 * 20

    using left most derivation 
    1) exp =>  exp op exp [exp => exp op exp]
    2) => n op exp [exp => n]
    3) => n + exp [op => +]
    4) => n + exp op exp [exp => exp op exp]
    5) => n + n op exp [exp => n]
    6) => n + n + exp [op => *]
    7) => n + n + n [exp => n]

    make parse tree using the above derivation:- 
    (following the steps of the derivation to create a tree like structure i.e. parse tree)
values in brackets represent the step in the derivation and will happen on the same time.
    exp => exp (1)
    exp => op (1) 
    exp => exp (1)

    exp => n (2)

    op => + (3) 

    exp => exp (4)
    exp => op (4) 
    exp => exp (4) 

    exp => n (5)
    
    op => * (6) 

    exp => n (7)



    exp => exp op exp | (exp) | n
    op => + | - | *


derive the following equation:-
30 * (40 - 20) + 40

using left most derivation:- 
1) exp => exp op exp [exp => exp op exp]
2) => n op exp [exp => n]
3) => n * exp [op => *]
4) => n * exp op exp [exp => exp op exp]
5) => n * (exp) op exp [exp => (exp)]
6) => n * (exp op exp) op exp [exp => exp op exp]
7) => n * (n op exp) op exp [exp => n]
8) => n * (n - exp) op exp [op => -]
9) => n * (n - n) op exp [exp => n]
10) => n * (n - n) + exp [op => +]
11) => n * (n - n) + n [exp => n]

make parse tree using the above derivation:- 
exp => exp (1) 
exp => op (1)
exp => exp (1) 

exp => n (2) 

op => * (3) 

exp => exp op exp (4) 

exp => (exp) (5)

exp => exp op exp (6)

exp => n (7) 

op => - (8)

exp => n (9) 

op => + (10)

exp => n (11)
</pre>


    <p class="text-center">Disadvantage of a Parse Tree</p>
    <p class="text-start">Parse trees are very big which has a lot of unnecessary information so we use Abstract Syntax
        Tree (AST).</p>
    <h6 class="text-center">Abstract Syntax Tree</h6>
    <div class="text-center">
        <img src="Pictures/ParseTree-vs-AbtractSyntaxTree.jpg" alt="check picture folder" class="img">
    </div>
    <p class="text-start dates">2nd November 2023</p>
    <h6 class="text-center">Ambiguity & Ambiguis Grammar</h6>
    <p class="text-start">If their exist 2 or more parse tree for same string than the grammar is called as Ambigous
        grammar.</p>
    <p class="text-start">There should be only 1 path to derive a string => parse tree like DFA.</p>
    <div class="text-center">
        <img src="Pictures/checking-ambiguity-by-derivations.jpg" alt="check picture folder" class="img">
    </div>
    <pre class="text-start">
    S => S | S*S | SS | () | Epsilon
here, S is non terminal and remaining everything is terminal... 
check if its ambigous or not?
Capital Sigma Set E = {Epsilon , + , * , () , ++ , ** , ()() , +() , ()+, *() , ()*...}
</pre>
    <p class="text-start">How to remove Ambiguity from the Grammar?</p>
    <p class="text-start">There are two ways to remove ambiguity from the ambiguis grammar:-</p>
    <ol>
        <li>re-write the grammar and change those productions that caused the ambiguity. For the above example, remove
            S+S, S*S, SS. It is beneficial but drains a lot of time.</li>
        <li>define some connective rules that can handle the ambiguous production rules. In this way, grammar remains
            unchanged but besides grammar there are some additional rules to handle the ambiguity. But, we need to care
            about additional rules which means more complexity. </li>
    </ol>
    <p class="text-start">2nd Option is better than the first one, complexity is ok but time saving must be there.</p>
    <h6 class="text-center">EBNF</h6>
    <p class="text-start">means Extended Backus Naur Form</p>
    <p class="text-start">EBNF has additional meta symbols (meta means specific use) like , (comma) , () (round
        brackets) , [] (square brackets) , {} (curly brackets).</p>
    <ol>
        <li>commas are used for concatenation.</li>
        <li>round brackets are used for grouping.</li>
        <li>square brackets are used for optional segment.</li>
        <li>curly brackets are used for repetition.</li>
    </ol>
    <pre class="text-start">
        CONCATENATION (commas)

        A => ab | ac 
        A => a,b | a,c 
        

        commas compromise concatenation so shouldn't be used as they are not recommended.
    </pre>
    <pre class="text-start">
    GROUPING (round brackets)
    
    only different values are grouped together.
    A => a + b | a - b 
    A => a (+ | -) b 

    A => a + b | a - c 
    A => a (+b | -c)
</pre>
    <pre class="text-start">
    OPTIONAL SEGMENTS (square brackets)

    A => ab | abc 
    A => ab (epsilon | c) (for explaination)
    so...
    A => ab[c] (actual result)
    

    if-statement => if (exp) statement | if (exp) statement else statement 
    if-statement => if (exp) statement [else statement]
</pre>
    <pre class="text-start">
    REPETITION (curly brackets)
they are used to represent recursions or repetitions.

A => aA | b 
A => b {a}
</pre>
    <p class="text-start dates">8th Nov 2023</p>
    <h6 class="text-center">EBNF</h6>
    <pre class="text-start">A => Aa | Ab | a | b 
        A => (a | b) A | (a | b) (explaination)
        A => (a | b) {(a | b)} (actual EBNF answer for regression)
        </pre>
    <h6 class="text-center">Syntax Diagram</h6>
    <p class="text-start">Syntax Diagram represents CFG (context free grammar) of a language in a graphical format.</p>
    <p class="text-start">CFG is a textual and SD is graphical. Syntax tree uses strings and is very different from
        syntax diagram. To draw and syntax diagram, the CFG has to be in EBNF.</p>
    <ol>
        <li>Syntax Diagram is a visual or graphical notation in which ovals represent terminals.</li>
        <li>rectanges represent non terminals.</li>
        <li>arrows represent flow.</li>
        <li>label represent the main non terminal of the production.</li>
    </ol>
    <div class="text-center">
        <img src="Pictures/Nov, 8th, Syntax Diagram CC-1.jpg" alt="check picture folder">

    </div>
    <div class="text-center">
        <img src="Pictures/Nov, 8th, Syntax Diagram CC-2.jpg" alt="check picture folder">
    </div>
    <p class="text-start dates">10th Nov 2023</p>
    <h6 class="text-center">Parsing</h6>
    <p class="text-start">Parsing is used to check the syntax of the grammar. There are 3 types of parsings.</p>
    <ol>
        <li>Predictive Parsing</li>
        <p class="text-start">There are two types of predictive parsings which are:-</p>
        <ol>
            <li>Top-Down Parsing</li>
            <p class="text-start">The input program is processed from left to right. It uses left most derivation to
                perform the parse. It can't work with left most recursion so that must be fixed before continuation.
                After fixation of left most recursion in the grammar, we apply the algorithms of top-down parsing. These
                algorithms include:-</p>
            <ol>
                <li>Recursion Descent</li>
                <p class="text-start">
                    It is a simple top-down algorithm which works after the removal of left most recursion from the
                    grammar. To remove the left most recursion, we convert BNF to EBNF (used for syntax diagram and the
                    removal of left recursion). In Recursion Descent, we write the procedures for every non terminal,
                    procedure means functions, we will write a function for all the available non terminals in the
                    grammar. Grammar includes a non terminal, terminal and the production symbols.
                </p>
                <ol>
                    <li>In case of a non terminal, a corresponding procedure is called.</li>
                    <li>In case of a terminal, a "match" operation is performed between the grammar and the input.</li>
                    <li>In case of productions, a suitable conditional or iterative statement is applied. Problems are
                        only when we have multiple productions. For repetition, we suit if else conditions.</li>
                </ol>
                <div class="text-center"><img src="Pictures/Nov, 10th, recursion descent working -1.jpg"
                        alt="check picture folder">
                </div>
                <div class="text-center"><img src="Pictures/Nov, 10th, recursion descent working -2.jpg"
                        alt="check picture folder">
                </div>
                <div class="text-center"><img src="Pictures/Nov, 10th, recursion descent working -3.jpg"
                        alt="check picture folder">
                </div>
                <div class="text-center"><img src="Pictures/Nov, 10th, recursion descent working -4.jpg"
                        alt="check picture folder">
                </div>
                <li>LL(1) Parsing Algorithm</li>
                <p class="text-start">
                    Input is to be processed from left to right, left most derivation is to be applied to perform the
                    parse. 1 look ahead token be used to predict the parse.
                </p>
                <ol>
                    <li>Remove left recursion without converting to EBNF, grammars stays in BNF.</li>
                    <li>perform left-factoring.</li>
                    <li>compute first and follow sets.</li>
                    <li>build the parsing table</li>
                    <li>perform the parse using parsing stack.</li>
                </ol>
                <pre class="text-start">replace the non terminals and match the terminals.</pre>
            </ol>
            <li>Bottom-Up Parsing</li>
        </ol>
        <li>Derivative Parsing</li>
        <li>Backtracking Parsing</li>
    </ol>

    <hr>
    <p class="text-start dates">15th Nov 2023</p>
    <h6 class="text-center">LL(1) Parsing Algorithm</h6>
    <p class="text-start">
        If we have left recursion, we remove it from grammar. If two or more common symbols at left, we factor them
        out...
    </p>
    <ol>
        <li>removing left recursion:-</li>
        <pre class="text-start">
            If we have a non terminal with the production of the form A => Aα | β,
            where beta doesn't begins with A than we remove left recursion as follows:-
            A => βA` , A` means A prime
            A` => αA` | epsilon
        </pre>
        <pre class="text-start">
            A => βα*
            since staris * can't be written so 
            A => βA`
A` => αA` | epsilon 


E => E + T | T 
mapping to the formula, we get 
A => Aα   | β, where beta represents T, alpha represents + T and A represents E 
so... 
E => TE` 
E` => +TE` | epsilon 
        </pre>
        <li>left factorization:-</li>
        <pre class="text-start">
            if we have a non terminal with productions of the form A => αβ | αγ, where alpha,beta and gamma are combinations of terminals and non terminals then we can do left factoring as follows:- 

            A => γ
        
        </pre>
    </ol>
    <div class="text-center"><img src="Pictures/Nov, 15th, Parsing -1.jpg" alt="check picture folder"></div>
    <div class="text-center"><img src="Pictures/Nov, 15th, Parsing -2.jpg" alt="check picture folder"></div>
    <div class="text-center"><img src="Pictures/Nov, 15th, Parsing -3.jpg" alt="check picture folder"></div>
    <div class="text-center"><img src="Pictures/Nov, 15th, Parsing -4.jpg" alt="check picture folder"></div>
    <hr>
    <h6 class="text-center">Parsing Algorithms Steps Explaination</h6>
    <pre class="text-start">
First set tells what symbols be the first ones in place of a terminal or non terminal during the derivation process. 
</pre>
    <ol>
        <p class="text-start">
            Since, the program requires proper calculations to perform the required string from grammar. So, there are
            rules required. Rules for Calculations:-
        </p>
        <li>Rule-1:- If X is a terminal then First(X) = {X}</li>
        <p class="text-start">the first set of a terminal is terminal itself.</p>
        <li>Rule-2a:- If X is a non terminal and has a product X => X1X2...Xn than First(X) = First(X1)-epsilon</li>
        <pre class="text-start">For Example:- 
            S => ABC
            X => X1X2X3 (mapping)

            Formula:- 
First (X) = First(X1) - epsilon 
First (S) = First(A) - epsilon 

non terminal will have first set from its first production.

S => Aa | Bb | Cc , where S is the first symbol 
let's suppose a grammar for the above 

A => aA | epsilon 
B => bB | epsilon 
C => cC | epsilon 

in this scenario, A is the first production of S so the values of A will be assigned to first symbol for S. 
first (A) = {a, epsilon} 
first (S) = {a} , because epsilon can never be assigned to S.
        </pre>
        <p class="text-start dates">17th Nov 2023</p>
        <li>Rule-2b:- </li>
        <pre class="text-start">we have studied rules 1 and 2a, now for epsilon, we use 2b and 2c...
            If there is a non-terminal having production of the form X=>X1X2...Xn 
            and First (X1) contains epsilon then First (X) contains First (X2) - {epsilon}
        
            # If the first production, A of S has an epsilon in it, we move on to the second production of S i.e. B and if B also has epsilon in it, we move on to the third production of S i.e. C.
        </pre>
        <li>Rule-2c:-</li>
        <pre class="text-start">if a non-terminal X can produce epsilon directly or indirectly than First(X) will contain {epsilon}
        
            S=> ABC 
            A=> aA | epsilon 
            B=> bB | c | epsilon 
            C=> cC | c | d

            here is an example for 2c (dealing with indirect epsilon)
            </pre>
        <table class="table table-responsive table-hover table-bordered">
            <tr>
                <th>Rules</th>
                <th>Pass 1</th>
                <th>Pass 2</th>
            </tr>
            <tr>
                <td>S=>ABC</td>
                <td>skip</td>
                <td>First(S) = {a,b,c,d}</td>
            </tr>
            <tr>
                <td>A=> aA</td>
                <td>First(A) = {a}</td>
                <td></td>
            </tr>
            <td>A=> epsilon</td>
            <td>First(A) = {epsilon}</td>
            <td></td>
            </tr>
            <tr>
                <td>B=> bB</td>
                <td>First(B) = {b}</td>
                <td></td>
            </tr>
            <tr>
                <td>B=> c</td>
                <td>First(B) = {b,c}</td>
                <td></td>
            </tr>
            <tr>
                <td>B=> epsilon</td>
                <td>First(B) = {b,c,epsilon}</td>
                <td></td>
            </tr>
            <tr>
                <td>C=> cC</td>
                <td>First(C) = {c}</td>
                <td></td>
            </tr>
            <tr>
                <td>C=> c</td>
                <td>First(C) = {c}</td>
                <td></td>
            </tr>
            <tr>
                <td>C=> d</td>
                <td>First(C) = {c,d}</td>
                <td></td>
            </tr>
        </table>
        <pre class="text-start">Formula (rule 2a) 
            First (X) = First(X1) - epsilon so no epsilon is to be given to X 

            (rule 2b)
            First (A) contains {epsilon}, then we will move on to the next production of S i.e. B and won't give epsilon to S.
        </pre>
    </ol>
    <pre class="text-start">Another Example:-

        S=> AaB | C 
        A=> aA | b 
        B=> bB | b 
        C=> cC | c  
    </pre>
    <table class="table table-responsive table-hover table-bordered">
        <tr>
            <th>Rules</th>
            <th>Pass 1</th>
            <th>Pass 2</th>
        </tr>
        <tr>
            <td>S=>AaB</td>
            <td>skip</td>
            <td>First(S) = {a,b,c}</td>
        </tr>
        <tr>
            <td>S=> C</td>
            <td>skip</td>
            <td></td>
        </tr>
        <tr>
            <td>A=> aA</td>
            <td>First(A) = {a}</td>
            <td></td>
        </tr>
        <td>A=> b</td>
        <td>First(A) = {a,b}</td>
        <td></td>
        </tr>
        <tr>
            <td>B=> bB</td>
            <td>First(B) = {b}</td>
            <td></td>
        </tr>
        <tr>
            <td>B=> b</td>
            <td>First(B) = {b}</td>
            <td></td>
        </tr>
        <tr>
            <td>C=> cC</td>
            <td>First(C) = {c}</td>
            <td></td>
        </tr>
        <tr>
            <td>C=> c</td>
            <td>First(C) = {c}</td>
            <td></td>
        </tr>
    </table>
    <div class="text-center"><img src="Pictures/Nov, 17th, 2c -1.jpg" alt="check picture folder"></div>
    <div class="text-center"><img src="Pictures/Nov, 17th, 2c -2.jpg" alt="check picture folder"></div>
    <p class="text-start dates">22nd Nov 2023</p>
    <h6 class="text-center">Follow Sets</h6>
    <ul>
        <li>follow sets are computed only for non-terminals</li>
        <li>an epsilon can't be a member of a follow set</li>
        <li>to compute follow sets, it is required to compute the first sets</li>
    </ul>
    <h6 class="text-start">Rules:-</h6>
    <p class="text-start">There are 3 rules with 2 exceptional cases.</p>
    <ol>
        <li>If S is the start symbol of the grammer, then $ will be in follow(S)</li>
        <li>If there is a production of the form A => X alpha beta then follow(X) will contain first(alpha) - {epsilon}
        </li>
        <pre class="text-start">
            example:- 
            A=> X alpha beta , where X, first set must be non terminal to compute the follow set.
            alpha, terminal and the follow set of the X 

            after computing X alpha, we move on to alpha beta 

            A=> X alpha beta 
            since, alpha is a terminal so we will skip.
        </pre>
        <li>if there is a production A=> X alpha beta and first(alpha) contains an epsilon then follow(X) will cotain
            first(beta) - {epsilon}</li>
        <pre class="text-start">
                A => X alpha beta 
                if alpha has epsilon then remove it

                A => X beta 
                so beta will be the follow set of X
                follow(X) = beta 
            </pre>
        <li>if tehre is a production A => alpha beta X, then follow(X) will contain follow(A)</li>
        <pre class="text-start">
            follow(X) = follow(X)
            if last value is a non terminal than follow sets of the label non terminal will be assigned to it.
        </pre>
        <li>if first(X) contains epsilon then follow(beta) will also contain follow(A)</li>
        <pre class="text-start">A=> alpha beta X
            if last non terminal X has epsilon, we will replae it with second last non terminal beta.

            example:- 
            A=> ABC | epsilon 
            B=> bBc | b 
            C=> cCd | c 
            writing first set directly

            FIRST(A) = {epsilon, b} 
            FIRST(B) = {b} 
            FIRST(C) = {c}
</pre>
    </ol>
    <table class="table table-hover table-bordered table-responsive">
        <tr>
            <th>Rules</th>
            <th>Ignore</th>
            <th>Pass1 (A=>ABC)</th>
            <th>Pass1 (B=>bBc)</th>
            <th>Pass1 (C=>cCd)</th>
        </tr>
        <tr>
            <td>A=>ABC</td>
            <td></td>
            <td>A=> ABC, follow(A) = {$,b}</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>A=>epsilon</td>
            <td>no follow set</td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>B=>bBc</td>
            <td></td>
            <td>FOLLOW(B) = {c}</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>B=>b</td>
            <td>terminal</td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>C=>cCd</td>
            <td></td>
            <td>FOLLOW(C) = {$,b} (we can remove this as it is modified next)</td>
            <td></td>
            <td>FOLLOW(C) = {$,b,d}</td>
        </tr>
        <tr>
            <td>C=>c</td>
            <td>terminal</td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>
    <pre class="text-start">if epsilon or terminal appear then follow sets are not possible so we skip them.

        A => ABC
        since A (non terminal) has epsilon in its first set, so will move on to B (non terminal). Since, B has no epsilon so the rules will end on it. 
    </pre>
    <pre class="text-start">
        E => EAT | T 
        A => + | - 
        T => TMF | F 
        M => * 
        F => (E) | n 
        </pre>
    <table class="table table-responsive table-hover table-bordered">
        <tr>
            <th>Rules</th>
            <th>Pass1</th>
            <th>Pass2</th>
            <th>Pass3</th>
        </tr>
        <tr>
            <td>E=> EAT</td>
            <td>skip</td>
            <td>skip</td>
            <td></td>
        </tr>
        <tr>
            <td>E=>T</td>
            <td>skip</td>
            <td>skip</td>
            <td>E = {(,n}</td>
        </tr>
        <tr>
            <td>A=> +</td>
            <td>FIRST(A) = {+}</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>A=> -</td>
            <td>FIRST(A) = {+,-}</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>T => TMF</td>
            <td>skip</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>T => F</td>
            <td>skip</td>
            <td>T = {(,n}</td>
            <td></td>
        </tr>
        <tr>
            <td>M => *</td>
            <td>FIRST(M) = {*}</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>F => (E)</td>
            <td>FIRST(F) = {(}</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>F => n</td>
            <td>FIRST(F) = {(,n}</td>
            <td></td>
            <td></td>
        </tr>
    </table>
    <hr class="final">
    <hr>
    <p class="text-start dates">6th December 2023</p>
    <p class="text-start">First Set:-</p>
    <pre class="text-start">S => (S) S | Epsilon 
</pre>
    <table class="table table-responsive table-hover table-bordered">
        <tr>
            <th></th>
            <th>FIRST</th>
            <th>FOLLOW</th>
        </tr>
        <tr>
            <td>S</td>
            <td>{(, epsilon}</td>
            <td>{$, )}</td>
        </tr>
    </table>
    <p class="text-start">dollar is used in place of terminal.</p>
    <h6 class="text-center">LL1-Parsing Algorithm</h6>
    <pre class="text-start">
        Building the Parsing Table 

        column represents terminals i.e. (,), epsilon 
        rows represents the non terminals i.e. S 
    </pre>
    <pre class="text-start">S => (S) S | Epsilon 
    </pre>
    <p class="text-start">epsilon is invisible in the parsing table.</p>
    <table class="table table-responsive table-hover table-bordered">
        <tr>
            <th></th>
            <th>(</th>
            <th>)</th>
            <th>$</th>
        </tr>
        <tr>
            <td>S</td>
            <td>S => (S)S (came on the basis of first rule)</td>
            <td>S => epsilon (came on the basis of follow set)</td>
            <td>S => epsilon (came on the basis of follow set)</td>
        </tr>
    </table>
    <pre class="text-start">LL1 uses lookahead symbol. Therefore, dollar symbol is used in the end.

        cells are filled on the basis of first sets and follow sets (if first set has epsilon). Some cells may or maynot be filled.
    </pre>
    <pre class="text-start">( is produced by first production so wrote first production.

        If we have only epsilon in first set, then we use follow sets. Otherwise, they are not used.

        Epsilon is not used in the first set until all non terminals have epsilon values.
    </pre>
    <pre class="text-start">
        S => ABC 
        A => aA | b | epsilon 
        B => bB | epsilon 
        C => cC | epsilon 
    </pre>
    <table class="table table-responsive table-hover table-bordered">
        <tr>
            <th></th>
            <th>FIRST SETS</th>
            <th>FOLLOW SETS</th>
        </tr>
        <tr>
            <td>S</td>
            <td>{a,b,c,epsilon}</td>
            <td>{$}</td>
        </tr>
        <tr>
            <td>A</td>
            <td>{a,b,epsilon}</td>
            <td>{$,b,c}</td>
        </tr>
        <tr>
            <td>B</td>
            <td>{b, epsilon}</td>
            <td>{$, c}</td>
        </tr>
        <tr>
            <td>C</td>
            <td>{b, epsilon}</td>
            <td>{$}</td>
        </tr>
    </table>
    <h6 class="text-center">Parsing Table</h6>
    <table class="table table-responsive table-hover table-bordered">
        <tr>
            <th></th>
            <th>a</th>
            <th>b</th>
            <th>c</th>
            <th>$</th>
        </tr>
        <tr>
            <td>S</td>
            <td>S => ABC</td>
            <td>S => ABC</td>
            <td>S => ABC</td>
            <td>S => ABC (since S has epsilon)</td>
        </tr>
        <tr>
            <td>A</td>
            <td>A => aA</td>
            <td>A => b , A => epsilon</td>
            <td>A => epsilon</td>
            <td>A => epsilon (since A has epsilon)</td>
        </tr>
        <tr>
            <td>B</td>
            <td></td>
            <td>B => bB</td>
            <td>B => epsilon</td>
            <td>B => epsilon (since B has epsilon)</td>
        </tr>
        <tr>
            <td>C</td>
            <td></td>
            <td></td>
            <td>C => cC</td>
            <td>C => epsilon (since C has epsilon)</td>
        </tr>
    </table>
    <h6 class="text-center">Syntax Checking / Performing the Parse</h6>

    <h6 class="text-start">LL1-Actions</h6>
    <ol>
        <li>Replace for Non Terminals</li>
        <li>Match for Terminals</li>
    </ol>
    <table class="table table-responsive table-hover table-bordered">
        <tr>
            <th>No.</th>
            <th>Parsing Stack</th>
            <th>Input</th>
            <th>Action</th>
        </tr>
        <tr>
            <td>1</td>
            <td>$S</td>
            <td>()$</td>
            <td>replace S => (S)S</td>
        </tr>
        <tr>
            <td>2</td>
            <td>$S)S(</td>
            <td>()$</td>
            <td>match</td>
        </tr>
        <tr>
            <td>3</td>
            <td>$S)S</td>
            <td>)$</td>
            <td>replace S => epsilon</td>
        </tr>
        <tr>
            <td>4</td>
            <td>$S)</td>
            <td>)$</td>
            <td>match</td>
        </tr>
        <tr>
            <td>5</td>
            <td>$S</td>
            <td>$</td>
            <td>replace S => epsilon</td>
        </tr>
        <tr>
            <td>6</td>
            <td>$</td>
            <td>$</td>
            <td>input accepted</td>
        </tr>
    </table>
    <p class="text-start">Solve the following:- (()) ()</p>
    <pre class="text-start">
        1) first set 
        2) follow set 
        3) parsing table 
        4) LL1-Actions
    </pre>
    <pre class="text-start">
        Solve the following:-
        
E => EAT | T 
A => + | - 
T => TMF | F 
M => * 
F => (E) | n 

remove left recursion... 

    </pre>
    <hr>
    <p class="text-start dates">Dec 13th, 2023</p>
    <h6 class="text-center">Bottom-Up Parsing</h6>
    <pre
        class="text-start">unlike top-down parsing which involve left most derivation, bottom-up parsing involve right most parsing.</pre>
    <pre class="text-start">It involve the following steps:- </pre>
    <ol>
        <li>right most derivation</li>
        <li>a new start symbol will be introduced in the grammer</li>
        <p class="text-start">S` => S, where S` means S prime</p>
        <p class="text-start">S => (S)S | alpha</p>
        <li>bottom-up parsing algo use DFA for parsing</li>
        <li>unlike LL(1) parsing which involves replace and match actions, bottom up involves shift (terminals) and
            reduce (non terminals) actions.</li>
        <li>that's the reason why bottom-up is also known as shift reduce parsing algorithm.</li>
        <li>famous algorithms for bottom-up parsing includes LR(0) and LR(1)</li>
    </ol>
    <H6 class="text-center">LR(0)</H6>
    <pre class="text-start">it has no problem with left recursion and has the following steps.</pre>
    <ol>
        <li>introduce a new start symbol</li>
        <li>list LR(0) items (by appending dots))</li>
        <li>construction of NFA of LR(0) items</li>
        <li>convert that NFA to DFA</li>
        <li>build LR(0) parsing table</li>
        <li>perform parsing using parsing stack</li>
    </ol>
    <p class="text-start">For Example: -</p>
    <pre class="text-start">
    S` => S
    S => (S)S | alpha
    </pre>
    <p class="text-start">step 2</p>
    <pre class="text-start">since, the question has 3 productions, we will have to append the dots (listing LR(0) items) to all of them separately. dot is places before and after every word until it reaches the end of the statement or the sentence. LR(0) items are of three main types. 
        1) Beginning LR(0) item: dot at first (.a)
        2) Complete LR(0) item: dot at end (a.)
        3) intermediate LR(0) item: dot in between the sentence (a.a)
    </pre>
    <p class="text-center"><img src="Pictures/bottomup1.PNG" alt="check picture folder"></p>
    <p class="text-start">step 3</p>
    <pre
        class="text-start">at first, we create the individual transitions that are taking place and then we fire epsilon transitions on the basis of 2 conditions. epsilon transition is fired only from the non terminal and secondly, the target state non terminal must also be equal to the source state non terminal.</pre>
    <div class="text-center"> <img src="Pictures/bottomup2.PNG" alt="check picture folder"></div>
    <div class="text-center"> <img src="Pictures/bottomup3.PNG" alt="check picture folder">
    </div>
    <pre class="text-start">to remove any confusion, making it again</pre>
    <div class="text-center"><img src="Pictures/bottomup4.PNG" alt="check picture folder"></div>
    <p class="text-start">step 4</p>
    <pre
        class="text-start">once, the transitions are completed and epsilon transitions are also fired, we will convert NFA to DFA. In the convertion procedure, we have to combine the entries on the basis of a condition. The target state of epsilon is merged to the source state of epsilon. this is to remove the epsilon which isn't present in DFAs.</pre>
    <p class="text-center"><img src="Pictures/bottomup5.PNG" alt="check picture folder"></p>
    <p class="text-start">step 5</p>
    <p class="text-center">Build LR(0) parsing table</p>
    <pre
        class="text-start">if we have beginning and intermediates LR(0) items, we consider them in shift state. otherwise, for complete LR(0) items, we consider them in reduced states.</pre>
    <p class="text-start">important practice question:- E => E + n | n</p>
    <hr>
    <p class="text-start dates">Dec 15th, 2023</p>
    <h6 class="text-center">Building LR(0) Parsing Table</h6>
    <pre
        class="text-start">here, I'll be using a instead of alpha, mistake which I did in the beginning and continued it until here. But, it's over now.</pre>
    <table class="table table-hover table-bordered table-responsive">
        <tr>
            <th>States</th>
            <th>Actions</th>
            <th>Rules</th>
            <th colspan="3">Inputs (non terminals)</th>
            <th>Go To (terminals)</th>
        </tr>
        <tr>
            <th></th>
            <th></th>
            <th></th>
            <th>(</th>
            <th>alpha / a</th>
            <th>)</th>
            <th></th>
        </tr>
        <tr>
            <td>0</td>
            <td>Shift</td>
            <th></th>
            <td>2</td>
            <td>6</td>
            <th></th>
            <td>1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>Reduced</td>
            <td>S`=>S</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>2</td>
            <td>Shift</td>
            <td></td>
            <td>2</td>
            <td>6</td>
            <td></td>
            <td>3</td>
        </tr>
        <tr>
            <td>3</td>
            <td>Shift</td>
            <td></td>
            <td></td>
            <td></td>
            <td>4</td>
            <td></td>
        </tr>
        <tr>
            <td>4</td>
            <td>Shift</td>
            <td></td>
            <td>2</td>
            <td>6</td>
            <td></td>
            <td>5</td>
        </tr>
        <tr>
            <td>5</td>
            <td>Reduced</td>
            <td>S => (S)S</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>6</td>
            <td>Reduced</td>
            <td>S=>a</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </table>
</body>
<h6 class="text-center">Processing of String</h6>
<pre class="text-start">
    Processing of the String happens in the reverse order and therefore called reverse engineering.
    
    here, we will give some input of our own choice and wil check if parsing is done smoothly or there is a mistake. $ in the beginning of parsing stack represents the stack is empty. And, the dollar in the end of input represents that it's the end.

Shift is used to put the element present at the left most position of the input to the top of the stack i.e. the right most position of the parsing stack.

Reduced uses some condition or rules to make an attempt to reduce the above parsing stack to a smaller value. This is done by remove the values and replacing them to the non terminals.

once, a step is performed, we check the right most 2 values in the parsing stack and check rows (first element) and column (second element) in teh parsing table and put that value at then next of those 2 elements.

$ table isn't made here as LR(0) can't look ahead.
</pre>
<table class="table table-hover table-responsive table-bordered">
    <tr>
        <th>No.</th>
        <th>Parsing Stack</th>
        <th>Inputs</th>
        <th>Actions</th>
    </tr>
    <tr>
        <td>1</td>
        <td>$0</td>
        <td>(a)a$</td>
        <td>Shift</td>
    </tr>
    <tr>
        <td>2</td>
        <td>$0(2</td>
        <td>a)a$</td>
        <td>Shift</td>
    </tr>
    <tr>
        <td>3</td>
        <td>$0(2a6</td>
        <td>)a$</td>
        <td>Reduce (S=>a)</td>
    </tr>
    <tr>
        <td>4</td>
        <td>$0(2S3</td>
        <td>)a$</td>
        <td>Shift</td>
    </tr>
    <tr>
        <td>5</td>
        <td>$0(2S3)4</td>
        <td>a$</td>
        <td>Shift</td>
    </tr>
    <tr>
        <td>6</td>
        <td>$0(2S3)4a6</td>
        <td>$</td>
        <td>Reduce (S=>a)</td>
    </tr>
    <tr>
        <td>7</td>
        <td>$0(2S3)4S5</td>
        <td>$</td>
        <td>Reduce [S=>(S)S]</td>
    </tr>
    <tr>
        <td>8</td>
        <td>$0S1</td>
        <td>$</td>
        <td>ACCEPTED</td>
    </tr>
</table>
<hr>
<p class="text-start dates">Dec 20th, 2023</p>
<pre class="text-start">The question begins with:- 
    E` => E 
    E => E + n | n 

    In step 2, we use the dots before and after every production.

    In step 3, we have to make the NFA by displaying the productions in a graphical format. After this is done, we fire the epsilon transition from every element having non terminal after the dot to every transition having a terminal after the dot. 
</pre>
<p class="text-center"><img src="Pictures/Dec-20th.1.png" alt="check picture folder"></p>
<pre class="text-start">
    In step 4, we merg all the elements from which the epsilon was fired and the elements to which the epsilon was fired. This makes it a DFA.
</pre>
<p class="text-center"><img src="Pictures/Dec-20th.2.png" alt="check picture folder"></p>
<pre
    class="text-start">If there is a duplicate transition, it's still a NFA as in this case. So we must also remove the duplicate transition by merging the target states for each duplicate transition. Then, we mark the states from 0 - the last value. Then we mark the states on the basis of shift and reduce states. 

If we have beginning or intermediate LR(0) items, it's a shift state.
If we have complete LR(0) items, it's a reduce state.

In those scenarios, where we have shift reduce state, we will conclude by saying that shift reduce conflict cannot work with LR(0) algo. We'll have to move on to SLR(1)</pre>
<p class="text-center"><img src="Pictures/Dec-20th.3.png" alt="check picture folder"></p>
<h6 class="text-center">SLR(1) | Simple, left to right, right derivation, one look ahead symbol or token.</h6>
<pre
    class="text-start">It has more and less the same steps as that of LR(0) algo. After step four where we had created the DFA using the NFA and got the duplicate state and then shift reduce conflict. After that, we have to find the follow sets of all the non terminals.</pre>
<p class="text-center"><img src="Pictures/Dec-20th.4.png" alt="check picture folder"></p>
<p class="text-center"><img src="Pictures/Dec-20th.5.png" alt="check picture folder"></p>
<pre
    class="text-start">In step 6, we have to create a parsing table which will be a little bit more compact as compared to the parsing table of LR(0) algo. In last step, we make a parsing stack to check a particular grammar, like for this case "n+n"</pre>
<p class="text-center"><img src="Pictures/Dec-20th.6.png" alt="check picture folder"></p>
<pre
    class="text-start">we must always start checking from 0 state, if we are unable to do it, it means that particular grammar isn't applicable. REJECTED</pre>
<p class="text-center"><img src="Pictures/Dec-20th.7.png" alt="check picture folder"></p>
<hr>
<p class="text-start dates">Dec 22nd, 2023</p>
<h6 class="text-center">SLR(1) Algorithm</h6>
<p class="text-center"><img src="Pictures/Dec-22nd.1.png" alt="Check picture folder"></p>
<pre
    class="text-start">Now, we'll be checking teh states having non terminal just after the LR(0) items. If there is, we need to go and check the productions of that state and find the beginning LR(0) items. We need to fire epsilon from the source to the target state.</pre>
<p class="text-center"><img src="Pictures/Dec-22nd.2.png" alt="Check picture folder"></p>
<pre
    class="text-start">merging the states having same target state. and numbering them randomly to be used in parsing table in the future. duplication is also removed to make it proper DFA.</pre>
<p class="text-center"><img src="Pictures/Dec-22nd.3.png" alt="Check picture folder"></p>
<pre class="text-start">follow sets are computed and '=' can be seen in the FOLLOW(V).

    because, S = > V = E , according to the rule # 2
</pre>
<p class="text-center"><img src="Pictures/Dec-22nd.4.png" alt="Check picture folder"></p>
<pre class="text-start">
    parsing table gives last state 7 a reduce reduced conflict because we have 2 reduce states in $ column. '=' has only one reduced rule i.e. r(v=>id) because of the follow(S)
</pre>
<hr>
</body>

</html>